{
    "collab_server" : "",
    "contents" : "#' @title ZIPPCAlnm\n#' @description Microbiome data denoising framework (mbDenoise) with zero-inflated probabilistic PCA with logistical normal multinomial model (ZIPPCA-LNM),\n#'              which can be used for downstream statistical analysis including ordination, compositional\n#'              normalization, differential abundance analysis, etc.\n#' @param X matrix of observations.\n#' @param V vector of the sample covariate.\n#' @param n.factors the rank or number of factors, after dimensional reduction. Defaults to 2.\n#' @param rank logical, if TRUE, the rank or number of factors, is chosen from 1 to 5 by BIC (Bayesian information criterion). Defaults to FALSE.\n#' @param trace logical, defaults to \\code{FALSE}. if \\code{TRUE} each current iteration step information will be printed.\n#' @param maxit maximum number of iterations within \\code{optim} and \\code{constrOptim} function, defaults to 100.\n#' @param parallel logical, if TRUE, use parallel toolbox to accelerate.\n\n#' @return\n#'\n#'\n#'  \\item{VLB }{ variational lower bound of log likelihood}\n#'  \\item{lvs}{list of latent variables\n#'  \\itemize{\n#'    \\item{pi }{ the probabilities of excess zeros}\n#'    \\item{factor_scores }{ coordinates or factor scores in low-dimensional subspace}\n#'    \\item{factor_scores2 }{ coordinates or factor scores in low-dimensional subspace with defalt rank 2, which is suitable for visualization.}\n#'    }}\n#'  \\item{params}{list of model parameters\n#'  \\itemize{\n#'    \\item{factor_coefs_j }{ coefficients of latent variables fator scores or factor loadings}\n#'    \\item{factor_coefs_0 }{ taxon-specific intercepts}\n#'    \\item{gamma }{ coeffcients of sample covariate}\n#'    \\item{tuo }{ taxon-specific parameter of zero-inflation probability}\n#'    \\item{c }{ sample-specific parameter of zero-inflation probability}\n#'    }}\n#'  \\item{Q }{ the underlying composition of microbiome data}\n#'  \\item{muz }{ the denoised counts of microbiome data}\n#'  \\item{bic}{ the number of the rank selection, chosen by BIC type information criterion}\n\n#' @examples\n#' n.n = 60\n#' n.w = 100\n#' n.factors = 2\n#' set.seed(1)\n#' si <- diag(n.factors)\n#' me <- c(0,0)\n#' f <- matrix(0,nrow = n.n, ncol = n.factors)\n#' for(i in 1:n.n){\n#'  f[i,] <- rnorm(n.factors, mean = 0, sd = 1)\n#' }\n#' betaj <- matrix(0,nrow = n.w, ncol = n.factors)\n#' for(j in 1:n.w){\n#'   betaj[j,] <- runif(n.factors,-1,1)\n#' }\n#' alpha <- rep(0,n.n)\n#' beta0 <- rep(0,n.w)\n#' g <- rep(0,n.w*0.5*0.5)\n#' gamma <- c(g,-g,rep(0,(n.w-n.w*0.5)))\n#' X_cov<- c(rep(1,n.n/2),rep(0,n.n/2))\n#' ll <- f %*% t(betaj) +matrix(alpha,n.n,n.w)+matrix(beta0,n.n,n.w,byrow=TRUE)\n#' exp_mat <- exp(ll)\n#' eta_mat <- matrix(0.25,n.n,n.w,byrow=TRUE)\n#' z <- matrix(0,n.n,n.w,byrow = TRUE)\n#' for(i in 1:n.n){\n#'   z[i,] <- rbinom(n.w, size=1, prob=eta_mat[i,])\n#' }\n#' sum <- rowSums((1-z)*exp_mat)\n#' Qn_z <- (1-z)*exp_mat/sum\n#' sum <- rowSums(exp_mat)\n#' Qn <- exp_mat/sum\n#' X <- matrix(0,n.n,n.w,byrow = TRUE)\n#' for(i in 1:n.n){\n#' X[i,] <- rmultinom(1, size = runif(1,80,800), prob = Qn[i,])\n#' }\n#' X[z==1]=0\n\n#' zerorow <- which(rowSums(X)==0)\n#' if(length(zerorow) >0 ){\n#'    X <- X[-zerorow,];X_cov<-X_cov[-zerorow];f <- f[-zerorow,];\n#'    Qn <- Qn[-zerorow,];Qn_z <- Qn_z[-zerorow,];\n#' }\n#' zerocol <- which(colSums(X)==0)\n#' if(length(zerocol) >0 ){\n#'   X <- X[,-zerocol];betaj <- t(t(betaj)[,-zerocol]);\n#'   Qn <- Qn[,-zerocol];Qn_z <- Qn_z[,-zerocol];\n#' }\n#' re_zilnm_cov <- ZIPPCAlnm(X,X_cov)\n#' re_zilnm <- ZIPPCAlnm(X)\n#'\n#' @export\n\nZIPPCAlnm <- function(X, V=NULL, n.factors=2, rank=FALSE,\n                      trace = FALSE, maxit = 100, parallel=TRUE){\n\n  ZILNMVA <- function(X,V,n.factors,trace,maxit) {\n\n    n.s<-nrow(X); n.f<-ncol(X);\n    M <- rowSums(X)\n    if(is.null(V)){Y <- 0\n    }else if(is.numeric(V)){Y <- V\n    }else{\n      Y <- as.numeric(as.factor(V))-1}\n\n    out.list <- list()\n\n    ### Initialization 1\n    pzero.col <- apply(X, 2, function(x) {sum(x==0)/n.s})\n    z.hat <- pi <- new.pi <- t(ifelse(t(X)==0, pzero.col, 0))\n    tuo_j <- car::logit(colMeans(pi))\n    c_i <- car::logit(rowMeans(pi))\n    #eta <- new.eta <- round(apply(pi, 2, mean), 6)\n    sigma <- new.sigma <- matrix(1,n.s,n.factors)\n    factor_coefs_0 <-  new.factor_coefs_0 <-  rep(1,n.f)\n    gamma <-  new.gamma <-  rep(1,n.f)\n\n    X.rc <- scale(log(X+0.05),scale = T,center = T)\n    re <- svd(X.rc,n.factors,n.factors)\n    factor_coefs_j <- new.factor_coefs_j <- re$v\n    if(n.factors==1){\n      factor_scores <- new.factor_scores <- re$u * (re$d[1])\n    }else{factor_scores <- new.factor_scores <- re$u %*% diag(re$d[1:n.factors])}\n\n\n    ### Initialization 2\n    cur.VLB <- -1e6; iter <- 1; ratio <- 10; diff=1e5;eps = 1e-4;max.iter = 100;\n    b.cur.logfunc <- -1e6;b0.cur.logfunc <- -1e6;f.cur.logfunc <- -1e6;ga.cur.logfunc <- -1e6\n\n    while((diff> eps*(abs(cur.VLB)+eps)) && iter <= max.iter) {\n      if(trace) cat(\"Iteration:\", iter, \"\\n\")\n      ## VLB\n      VLB_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        y1 <- X*ll\n        y2 <- -X*log(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        fun2 <- function(i) { 0.5 * (sum(log(t(new.sigma)[,i])) - sum(t(new.sigma)[,i]) - sum(new.factor_scores[i,]^2))}\n\n        y <- sum(y1)+sum(y2)+sum(sapply(1:n.s,fun2))\n        return(y)\n      }\n\n      ###optim f\n      f_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        lf <- new.factor_scores %*% t(new.factor_coefs_j)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        y1 <- X*lf\n        y2 <- -X*log(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        fun2 <- function(i) { 0.5 * (- sum(new.factor_scores[i,]^2))}\n        y <- sum(y1)+sum(y2)+sum(sapply(1:n.s,fun2))\n\n        return(y)\n      }\n      f_grad_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        sum <- exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))/(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        fun2 <- function(i) { -new.factor_scores[i,]+(X[i,])%*%new.factor_coefs_j-(M[i]*sum[i,])%*%new.factor_coefs_j}\n        f_grad <- t(sapply(1:n.s,fun2))\n        return(c(f_grad))\n      }\n\n      q <- try(optim(c(factor_scores), x=new.factor_coefs_0,b=new.factor_coefs_j,s=new.sigma,g=new.gamma, method = \"BFGS\", fn = f_f_ini, gr = f_grad_f_ini, control = list(trace = 0,  fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_scores <- factor_scores;\n      }else{\n        if(iter > 1 && f.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of mu did not improve on iteration step \",iter,\"\\n\");\n          new.factor_scores <- factor_scores;\n        }else{\n          if(trace) cat(\"Variational parameters mu updated\",\"\\n\")\n          new.factor_scores <- matrix(q$par,n.s,n.factors);\n          new.factor_scores <- scale(new.factor_scores)\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of mu did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ###update sigma\n      beta2 <- new.factor_coefs_j^2\n      ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n      sum <- M*exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))/(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n      for(i in 1:n.s){\n        if(n.factors==1){\n          new.sigma[i] <- 1/(1+(apply((sum)[i,]*beta2,2,sum)))\n        }else{\n          new.sigma[i,] <- 1/(1+(diag(diag(apply((sum)[i,]*beta2,2,sum)))))\n        }}\n\n      ###update beta\n      beta_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        lf <- new.factor_scores %*% t(new.factor_coefs_j)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n\n        y1 <- X*lf\n        y2 <- -X*log(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        y <- sum(y1)+sum(y2)\n\n        return(y)\n      }\n      beta_grad_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        b3 <- NULL\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        sum <- M*exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))/(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        for(p in 1:n.factors){\n          b3 <- c(b3,(sweep(X,1,new.factor_scores[,p],\"*\") -sweep((new.sigma[,p]%*%t(new.factor_coefs_j[,p])),1,new.factor_scores[,p],\"+\") * sum))\n        }\n\n        b3 <- matrix(b3,n.s,n.f*n.factors)\n        return(c(colSums(b3)))\n      }\n\n      q <- try(optim(c(factor_coefs_j), x=new.factor_coefs_0,f=new.factor_scores,s=new.sigma, g=new.gamma,method = \"BFGS\", fn = beta_f_ini, gr = beta_grad_f_ini, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_coefs_j <- factor_coefs_j;\n      }else{\n        if(iter > 1 && b.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of beta did not improve on iteration step \",iter,\"\\n\");\n          new.factor_coefs_j <- factor_coefs_j;\n        }else{\n          if(trace) cat(\"Model parameters beta updated\",\"\\n\")\n          new.factor_coefs_j <- matrix(q$par,n.f,n.factors);\n          #new.factor_coefs_j <- scale(new.factor_coefs_j)\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of beta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ###update beta0\n      b0_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        lab <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n\n        y1 <- X*lab\n        y2 <- -X*log(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        y <- sum(y1)+sum(y2)\n\n        return(y)\n      }\n      b0_grad_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        grad <- X-M*exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))/(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        return(c(colSums(grad)))\n      }\n\n      q <- try(optim(c(factor_coefs_0),b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma,g=new.gamma,method = \"BFGS\", fn = b0_f_ini, gr = b0_grad_f_ini, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_coefs_0 <- factor_coefs_0\n      }else{\n        if(iter > 1 && b0.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of beta did not improve on iteration step \",iter,\"\\n\");\n          new.factor_coefs_0 <- factor_coefs_0\n        }else{\n          if(trace) cat(\"Model parameters beta updated\",\"\\n\")\n          new.factor_coefs_0 <- q$par;\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of beta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ###update gamma\n      gam_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        lab <- matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n\n        y1 <- X*lab\n        y2 <- -X*log(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        y <- sum(y1)+sum(y2)\n\n        return(y)\n      }\n      gam_grad_f_ini <- function(x,b=NULL,f=NULL,s=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        grad <- X*Y-M*exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))/(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))*Y\n\n        return(c(colSums(grad)))\n      }\n\n      q <- try(optim(c(gamma),b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma,x=new.factor_coefs_0,method = \"BFGS\", fn = gam_f_ini, gr = gam_grad_f_ini, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.gamma <- gamma\n      }else{\n        if(iter > 1 && ga.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of gamma did not improve on iteration step \",iter,\"\\n\");\n          new.gamma <- gamma\n        }else{\n          if(trace) cat(\"Model parameters gamma updated\",\"\\n\")\n          new.gamma <- q$par;\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of gamma did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      q1 <- list(value = beta_f_ini(c(new.factor_coefs_j),x=new.factor_coefs_0,f=new.factor_scores,s=new.sigma,g=new.gamma))\n      b.new.logfunc <- q1$value\n      b.cur.logfunc <- b.new.logfunc\n\n      q2 <- list(value = f_f_ini(c(new.factor_scores),x=new.factor_coefs_0, b=new.factor_coefs_j,s=new.sigma,g=new.gamma))\n      new.f.cur.logfunc <- q2$value\n      f.cur.logfunc <- new.f.cur.logfunc\n\n      q3 <- list(value = b0_f_ini(c(new.factor_coefs_0), f=new.factor_scores,b=new.factor_coefs_j,s=new.sigma,g=new.gamma))\n      new.b0.cur.logfunc <- q3$value\n      b0.cur.logfunc <- new.b0.cur.logfunc\n\n      q4 <- list(value = gam_f_ini(c(new.gamma), f=new.factor_scores,b=new.factor_coefs_j,s=new.sigma,x=new.factor_coefs_0))\n      new.ga.cur.logfunc <- q4$value\n      ga.cur.logfunc <- new.ga.cur.logfunc\n\n      ## Take values of VLB to define stopping rule\n      q <- list(value = VLB_ini(c(new.factor_coefs_0),b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma,g=new.gamma))\n      new.VLB <-  tryCatch({q$value},error=function(e){NaN})\n      diff=abs(new.VLB-cur.VLB)\n      ratio <- abs(new.VLB/cur.VLB);\n      if(trace) cat(\"New VLB:\", new.VLB,\"cur VLB:\", cur.VLB, \"Ratio of VLB\", ratio, \". Difference in VLB:\",diff,\"\\n\")\n      cur.VLB <- new.VLB\n\n      if(is.na(cur.VLB)){\n        sigma <- new.sigma <- matrix(1,n.s,n.factors)\n        factor_coefs_0 <-  new.factor_coefs_0 <-  rep(1,n.f)\n        gamma <-  new.gamma <-  rep(1,n.f)\n        X.rc <- scale(log(X+0.05),scale = T,center = T)\n        re <- svd(X.rc,n.factors,n.factors)\n        factor_coefs_j <- new.factor_coefs_j <- re$v\n        if(n.factors==1){\n          factor_scores <- new.factor_scores <- re$u * (re$d[1])\n        }else{factor_scores <- new.factor_scores <- re$u %*% diag(re$d[1:n.factors])}\n        iter <- 101\n\n      }else{\n        factor_coefs_0 <-new.factor_coefs_0\n        factor_coefs_j <- new.factor_coefs_j\n        factor_scores <- new.factor_scores\n        sigma <- new.sigma\n        gamma <- new.gamma\n        iter <- iter + 1\n      }\n    }\n\n    ###VA iteration\n    cur.VLB <- -1e6; iter <- 1; ratio <- 10; diff=1e5;eps = 1e-4;max.iter = 100;\n    b.cur.logfunc <- -1e6;b0.cur.logfunc <- -1e6;f.cur.logfunc <- -1e6;ga.cur.logfunc <- -1e6\n    e.cur.logfunc <- -1e6;\n\n    while((diff> eps*(abs(cur.VLB)+eps)) && iter <= max.iter) {\n      if(trace) cat(\"Iteration:\", iter, \"\\n\")\n      ## VLB\n      VLB <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,e=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n        new.tuo <- e[1:n.f]; e <- e[-(1:n.f)]\n        new.ci <- e[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        y1 <- X*ll\n        y2 <- -X*log(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n        fun2 <- function(i) { 0.5 * (sum(log(t(new.sigma)[,i])) - sum(t(new.sigma)[,i]) - sum(new.factor_scores[i,]^2))}\n        y3 <- new.pi*new.eta-log(1+exp(new.eta))-(1-new.pi)*log(1-new.pi)-I(X==0)*new.pi*log(new.pi)\n\n        y <- sum(y1)+sum(y2)+sum(sapply(1:n.s,fun2))+sum(y3,na.rm=T)\n        return(y)\n      }\n\n      ###optim pi\n      ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n      #alp <- log(M/(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))))))\n      alp <- log(M/(rowSums((exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2))))))\n      new.eta <- matrix(tuo_j,n.s, n.f,byrow = T)+ matrix(c_i,n.s, n.f)\n      e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)+matrix(alp,n.s,n.f)\n      sum1 <- exp( - exp(e.mat))\n      new.pi <- 1/(1+exp(-new.eta)*sum1)\n      new.pi[X!=0]=0\n\n      ###optim f\n      # # ###optim f\n      f_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        lf <- new.factor_scores %*% t(new.factor_coefs_j)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        y1 <- X*lf\n        y2 <- -X*log(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        fun2 <- function(i) { 0.5 * (- sum(new.factor_scores[i,]^2))}\n        y <- sum(y1)+sum(y2)+sum(sapply(1:n.s,fun2))\n\n        return(y)\n      }\n      f_grad_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        sum <- I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))/(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        # fun2 <- function(i) { -new.factor_scores[i,]+(X[i,])%*%new.factor_coefs_j-(X[i,]*sum[i,])%*%new.factor_coefs_j-\n        #                       (new.re[i]*sum[i,])%*%new.factor_coefs_j}\n        fun2 <- function(i) { -new.factor_scores[i,]+(X[i,])%*%new.factor_coefs_j-(M[i]*sum[i,])%*%new.factor_coefs_j}\n        f_grad <- t(sapply(1:n.s,fun2))\n        return(c(f_grad))\n      }\n\n      q <- try(optim(c(factor_scores), x=new.factor_coefs_0,b=new.factor_coefs_j,s=new.sigma,pi=new.pi,g=new.gamma, method = \"BFGS\", fn = f_f, gr = f_grad_f, control = list(trace = 0,  fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_scores <- factor_scores;\n      }else{\n        if(iter > 1 && f.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of mu did not improve on iteration step \",iter,\"\\n\");\n          new.factor_scores <- factor_scores;\n        }else{\n          if(trace) cat(\"Variational parameters mu updated\",\"\\n\")\n          new.factor_scores <- matrix(q$par,n.s,n.factors);\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of mu did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ###update sigma\n      beta2 <- new.factor_coefs_j^2\n      ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n      sum <- M*I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))/(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n      for(i in 1:n.s){\n        if(n.factors==1){\n          new.sigma[i] <- 1/(1+(apply((sum)[i,]*beta2,2,sum)))\n        }else{\n          new.sigma[i,] <- 1/(1+(diag(diag(apply((sum)[i,]*beta2,2,sum)))))\n        }}\n\n\n      ###update beta\n      beta_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        lf <- new.factor_scores %*% t(new.factor_coefs_j)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n\n        y1 <- X*lf\n        y2 <- -X*log(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        y <- sum(y1)+sum(y2)\n\n        return(y)\n      }\n      beta_grad_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        b3 <- NULL\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        sum <- M*I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))/(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        for(p in 1:n.factors){\n          b3 <- c(b3,(sweep(X,1,new.factor_scores[,p],\"*\") -sweep((new.sigma[,p]%*%t(new.factor_coefs_j[,p])),1,new.factor_scores[,p],\"+\") * sum))\n        }\n\n        b3 <- matrix(b3,n.s,n.f*n.factors)\n        return(c(colSums(b3)))\n      }\n\n      q <- try(optim(c(factor_coefs_j), x=new.factor_coefs_0,f=new.factor_scores,s=new.sigma,pi=new.pi, g=new.gamma, method = \"BFGS\", fn = beta_f, gr = beta_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_coefs_j <- factor_coefs_j;\n      }else{\n        if(iter > 1 && b.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of beta did not improve on iteration step \",iter,\"\\n\");\n          new.factor_coefs_j <- factor_coefs_j;\n        }else{\n          if(trace) cat(\"Model parameters beta updated\",\"\\n\")\n          new.factor_coefs_j <- matrix(q$par,n.f,n.factors);\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of beta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ###update beta0\n      b0_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        lab <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n\n        y1 <- X*lab\n        y2 <- -X*log(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        y <- sum(y1)+sum(y2)\n\n        return(y)\n      }\n      b0_grad_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        grad <- X-M*I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))/(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        return(c(colSums(grad)))\n      }\n\n\n      q <- try(optim(c(factor_coefs_0),b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma, pi=new.pi,g=new.gamma, method = \"BFGS\", fn = b0_f, gr = b0_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_coefs_0 <- factor_coefs_0\n      }else{\n        if(iter > 1 && b0.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of beta did not improve on iteration step \",iter,\"\\n\");\n          new.factor_coefs_0 <- factor_coefs_0\n        }else{\n          if(trace) cat(\"Model parameters beta updated\",\"\\n\")\n          new.factor_coefs_0 <- q$par\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of beta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ###update gamma\n      ga_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        lab <- matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n\n        y1 <- X*lab\n        y2 <- -X*log(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))\n\n        y <- sum(y1)+sum(y2)\n\n        return(y)\n      }\n      ga_grad_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y+new.factor_scores %*% t(new.factor_coefs_j)\n        grad <- X*Y-M*I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))/(rowSums(I((1-new.pi)>0.5)*(exp(ll+0.5*(new.sigma) %*% t(new.factor_coefs_j^2)))))*Y\n\n        return(c(colSums(grad)))\n      }\n\n\n      q <- try(optim(c(gamma),b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma, pi=new.pi,x=new.factor_coefs_0, method = \"BFGS\", fn = ga_f, gr = ga_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.gamma <- gamma\n      }else{\n        if(iter > 1 && ga.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of gamma did not improve on iteration step \",iter,\"\\n\");\n          new.gamma <- gamma\n        }else{\n          if(trace) cat(\"Model parameters gamma updated\",\"\\n\")\n          new.gamma <- q$par\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of gamma did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ## update tuo,ci\n      eta_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL,e=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n        new.tuo <- e[1:n.f]; e <- e[-(1:n.f)]\n        new.ci <- e[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n\n        y1 <- new.pi*new.eta-log(1+exp(new.eta))\n        y <- sum(y1)\n        return(y)\n      }\n      eta_grad_f <- function(x,b=NULL,f=NULL,s=NULL,pi=NULL,g=NULL,e=NULL) {\n        new.factor_coefs_0 <- x[1:n.f];\n        new.factor_coefs_j <- matrix(b,n.f,n.factors)\n        new.factor_scores <- matrix(f,n.s,n.factors)\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- matrix(pi,n.s,n.f)\n        new.gamma <- g[1:n.f];\n        new.tuo <- e[1:n.f]; e <- e[-(1:n.f)]\n        new.ci <- e[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n\n        grad <- new.pi-exp(new.eta)/(1+exp(new.eta))\n\n        return(c(colSums(grad), rowSums(grad)))\n      }\n      q <- try(optim(c(tuo_j,c_i),g=new.gamma,b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma, pi=new.pi,x=new.factor_coefs_0, method = \"BFGS\", fn = eta_f, gr = eta_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.tuo <- tuo_j; new.ci <- c_i;\n      }else{\n        if(iter > 1 && e.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of eta did not improve on iteration step \",iter,\"\\n\");\n          new.tuo <- tuo_j; new.ci <- c_i;\n        }else{\n          if(trace) cat(\"Model parameters eta updated\",\"\\n\")\n          new.tuo <- q$par[1:n.f]; x2 <- q$par[-(1:n.f)];\n          new.ci <- x2[1:n.s]\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of eta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      q1 <- list(value = beta_f(c(new.factor_coefs_j),x=new.factor_coefs_0,f=new.factor_scores,s=new.sigma,pi=new.pi,g=new.gamma))\n      b.new.logfunc <- q1$value\n      b.cur.logfunc <- b.new.logfunc\n\n      q2 <- list(value = f_f(c(new.factor_scores),x=new.factor_coefs_0, b=new.factor_coefs_j,s=new.sigma,pi=new.pi,g=new.gamma))\n      new.f.cur.logfunc <- q2$value\n      f.cur.logfunc <- new.f.cur.logfunc\n\n      q3 <- list(value = b0_f(c(new.factor_coefs_0), f=new.factor_scores,b=new.factor_coefs_j,s=new.sigma,pi=new.pi,g=new.gamma))\n      new.b0.cur.logfunc <- q3$value\n      b0.cur.logfunc <- new.b0.cur.logfunc\n\n      q4 <- list(value = ga_f(c(new.gamma), f=new.factor_scores,b=new.factor_coefs_j,s=new.sigma,pi=new.pi,x=new.factor_coefs_0))\n      new.ga.cur.logfunc <- q4$value\n      ga.cur.logfunc <- new.ga.cur.logfunc\n\n      q5 <- list(value = eta_f(c(new.tuo,new.ci),g=new.gamma, f=new.factor_scores,b=new.factor_coefs_j,s=new.sigma,pi=new.pi,x=new.factor_coefs_0))\n      new.e.cur.logfunc <- q5$value\n      e.cur.logfunc <- new.e.cur.logfunc\n\n      ## Take values of VLB to define stopping rule\n      q <- list(value = VLB(c(new.factor_coefs_0),b=new.factor_coefs_j,f=new.factor_scores,s=new.sigma,pi=new.pi,e=c(new.tuo,new.ci),g=new.gamma))\n      new.VLB <- q$value\n      diff=abs(new.VLB-cur.VLB)\n      ratio <- abs(new.VLB/cur.VLB);\n      if(trace) cat(\"New VLB:\", new.VLB,\"cur VLB:\", cur.VLB, \"Ratio of VLB\", ratio, \". Difference in VLB:\",diff,\"\\n\")\n      cur.VLB <- new.VLB\n\n      factor_coefs_0 <-new.factor_coefs_0\n      factor_coefs_j <- new.factor_coefs_j\n      pi <- new.pi\n      tuo_j <- new.tuo;\n      c_i <- new.ci;\n      factor_scores <- new.factor_scores\n      sigma <- new.sigma\n      gamma <- new.gamma\n      iter <- iter + 1\n    }\n\n    ll <- matrix(factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(gamma,n.s,n.f,byrow=TRUE)*Y+factor_scores %*% t(factor_coefs_j)\n    exp.mat <- exp(ll+0.5*(sigma) %*% t(factor_coefs_j^2))\n    sum <- exp.mat/(rowSums(exp.mat))\n    exp_z <- (1-new.pi)*exp(ll+0.5*(sigma) %*% t(factor_coefs_j^2))\n    sum_z <- (1-new.pi)*exp.mat/(rowSums((1-new.pi)*exp.mat))\n\n\n    if(iter > 99){\n      print(\"ZILNMVA Not converging!\")\n    }\n\n    ## print the output\n    out.list$VLB <- cur.VLB\n    out.list$iter=iter-1\n    out.list$lvs$pi <- pi\n    out.list$lvs$factor_scores <- factor_scores\n    out.list$params$tuo <- tuo_j\n    out.list$params$c <- c_i\n    out.list$params$factor_coefs_j <- factor_coefs_j\n    out.list$params$factor_coefs_0 <- factor_coefs_0\n    out.list$params$gamma <- gamma\n    out.list$lvs$sigma <- sigma\n    out.list$Q <- sum\n    out.list$mu <- exp.mat\n    out.list$muz <- exp_z\n    out.list$Qz <- sum_z\n\n    return(out.list)\n  }\n\n  if(rank==FALSE){\n    re <- tryCatch({ZILNMVA(X,V,n.factors,trace,maxit)},error=function(e){NaN})\n    #re <- ZILNMVA(X,V,n.factors,trace,maxit)\n\n  }else{\n    if (parallel){\n      #cl <- parallel::makeCluster(detectCores(logical = FALSE))\n      cl <- parallel::makeCluster(getOption(\"cl.cores\", 4))\n      doParallel::registerDoParallel(cl)\n    }\n    out.list <- list()\n    p <- ncol(X)\n    n <- nrow(X)\n    r <- 5\n    fold <- 5\n    beta <- list()\n    beta0 <- list()\n    f <- list()\n    Q <- list()\n    pi <- list()\n    mu <- list()\n    gamma <- list()\n    sigma <- list()\n    Qz <- list()\n    muz <- list()\n    tuo <- list()\n    c <- list()\n    iter <- rep(NaN,r)\n    L <- rep(NaN,r)\n    G_w <- rep(NaN,r);bic <- rep(NaN,r);\n\n    if (parallel){\n      Mres <- foreach::foreach(w=1:r) %dopar% {\n        re <- tryCatch({ZILNMVA(X,V,n.factors=w,trace,maxit)},error=function(e){NaN})\n        re\n      }\n      for(w in 1:r){\n        if(!is.na(Mres[[w]]$VLB)){\n          L[w] <- Mres[[w]]$VLB\n          iter[w] <- Mres[[w]]$iter\n          beta[[w]] <- Mres[[w]]$params$factor_coefs_j\n          beta0[[w]] <- Mres[[w]]$params$factor_coefs_0\n          gamma[[w]] <- Mres[[w]]$params$gamma\n          f[[w]] <- Mres[[w]]$lvs$factor_scores\n          sigma[[w]] <- Mres[[w]]$lvs$sigma\n          pi[[w]] <- Mres[[w]]$lvs$pi\n          mu[[w]] <- Mres[[w]]$mu\n          Qz[[w]] <- Mres[[w]]$Qz\n          Q[[w]] <- Mres[[w]]$Q\n          muz[[w]] <- Mres[[w]]$muz\n          tuo[[w]] <- Mres[[w]]$params$tuo\n          c[[w]] <- Mres[[w]]$params$c\n          G_w[w] <- w*p-w^2+2*w*n\n          bic[w] <- -2*L[w]+(log(n)+log(p))*G_w[w]\n        }else{\n          L[w] <- NaN\n          iter[w] <- NaN\n          beta[[w]] <- NaN\n          beta0[[w]] <- NaN\n          tuo[[w]] <- NaN\n          c[[w]] <- NaN\n          gamma[[w]] <- NaN\n          sigma[[w]] <- NaN\n          f[[w]] <- NaN\n          Q[[w]] <- NaN\n          Qz[[w]] <- NaN\n          pi[[w]] <- NaN\n          G_w[w] <- NaN\n          bic[w] <- NaN\n          mu[[w]] <- NaN\n          muz[[w]] <- NaN\n        }\n      }\n    }else{\n      for(w in 1:r){\n        re <- tryCatch({ZILNMVA(X,V,n.factors=w,trace,maxit)},error=function(e){NaN})\n        if(!is.na(re$VLB)){\n          L[w] <- re$VLB\n          iter[w] <- re$iter\n          beta[[w]] <- re$params$factor_coefs_j\n          beta0[[w]] <- re$params$factor_coefs_0\n          gamma[[w]] <- re$params$gamma\n          sigma[[w]] <- re$lvs$sigma\n          f[[w]] <- re$lvs$factor_scores\n          Q[[w]] <- re$Q\n          mu[[w]] <- re$mu\n          Qz[[w]] <- re$Qz\n          muz[[w]] <- re$muz\n          tuo[[w]] <- re$params$tuo\n          c[[w]] <- re$params$c\n          pi[[w]] <- re$lvs$pi\n          G_w[w] <- w*p-w^2+2*w*n\n          bic[w] <- -2*L[w]+(log(n)+log(p))*G_w[w]\n        }else{\n          L[w] <- NaN\n          iter[w] <- NaN\n          beta[[w]] <- NaN\n          beta0[[w]] <- NaN\n          tuo[[w]] <- NaN\n          c[[w]] <- NaN\n          gamma[[w]] <- NaN\n          sigma[[w]] <- NaN\n          f[[w]] <- NaN\n          Q[[w]] <- NaN\n          Qz[[w]] <- NaN\n          pi[[w]] <- NaN\n          G_w[w] <- NaN\n          bic[w] <- NaN\n          mu[[w]] <- NaN\n          muz[[w]] <- NaN\n        }\n      }\n    }\n    out.list$bic <- which.min(bic)\n    out.list$VLB <- L[[(which.min(bic))]]\n    out.list$iter <- iter[[(which.min(bic))]]\n    out.list$lvs$pi <- pi[[(which.min(bic))]]\n    out.list$lvs$factor_scores <- f[[(which.min(bic))]]\n    out.list$lvs$factor_scores2 <- f[[2]]\n    out.list$lvs$sigma <- sigma[[(which.min(bic))]]\n    out.list$params$factor_coefs_j <- beta[[(which.min(bic))]]\n    out.list$params$factor_coefs_0 <- beta0[[(which.min(bic))]]\n    out.list$params$gamma <- gamma[[(which.min(bic))]]\n    out.list$params$tuo <- tuo[[(which.min(bic))]]\n    out.list$params$c <- c[[(which.min(bic))]]\n    out.list$Q <- Q[[(which.min(bic))]]\n    out.list$mu <- mu[[(which.min(bic))]]\n    out.list$muz <- muz[[(which.min(bic))]]\n    out.list$Qz <- Qz[[(which.min(bic))]]\n\n    if (parallel){\n      parallel::stopCluster(cl = cl)\n    }\n    return(out.list)\n\n  }\n}\n",
    "created" : 1624784551214.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "87|65|885|0|\n",
    "hash" : "3990900837",
    "id" : "B2DF112E",
    "lastKnownWriteTime" : 1624806453,
    "last_content_update" : 1624806453420,
    "path" : "~/云盘/mbDenoise/R/ZIPPCAlnm.R",
    "project_path" : "R/ZIPPCAlnm.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}