{
    "collab_server" : "",
    "contents" : "#' @title ZIPPCApn\n#' @description Microbiome data denoising framework (mbDenoise) with zero-inflated probabilistic PCA with Poisson (ZIPPCA-Poi) and negative-binomial model (ZIPPCA-NB),\n#'              which can be used for downstream statistical analysis including ordination, compositional\n#'              normalization, differential abundance analysis, etc. mbDenoise with ZIPPCA-NB model is recommended for empirical data analysis.\n#' @param X matrix of observations.\n#' @param V vector of the sample covariate.\n#' @param family distribution of models. Two options are \"poisson\" and \"negative.binomial\". Defaults to \"negative.binomial\".\n#' @param n.factors the rank or number of factors, after dimensional reduction. Defaults to 2.\n#' @param rank logical, if TRUE, the rank or number of factors, is chosen from 1 to 5 by HIC (hybrid information criterion). Defaults to FALSE.\n#' @param trace logical, defaults to \\code{FALSE}. if \\code{TRUE} each current iteration step information will be printed.\n#' @param maxit maximum number of iterations within \\code{optim} and \\code{constrOptim} function, defaults to 100.\n#' @param parallel logical, if TRUE, use parallel toolbox to accelerate.\n\n#' @return\n#'\n#'\n#'  \\item{VLB }{ variational lower bound of log likelihood}\n#'  \\item{lvs}{list of latent variables\n#'  \\itemize{\n#'    \\item{pi }{ the probabilities of excess zeros}\n#'    \\item{factor_scores }{ coordinates or factor scores in low-dimensional subspace}\n#'    \\item{factor_scores2 }{ coordinates or factor scores in low-dimensional subspace with defalt rank 2, which is suitable for visualization.}\n#'    }}\n#'  \\item{params}{list of model parameters\n#'  \\itemize{\n#'    \\item{factor_coefs_j }{ coefficients of latent variables fator scores or factor loadings}\n#'    \\item{factor_coefs_0 }{ taxon-specific intercepts}\n#'    \\item{alpha }{ sample-specifc coeffcient that adjusts for the sequencing depth}\n#'    \\item{dispersion }{ taxon-specific over-dispersion parameter for negative binomial distribution}\n#'    \\item{gamma }{ coeffcients of sample covariate}\n#'    \\item{tuo }{ taxon-specific parameter of zero-inflation probability}\n#'    \\item{c }{ sample-specific parameter of zero-inflation probability}\n#'    }}\n#'  \\item{Q }{ the underlying composition of microbiome data}\n#'  \\item{muz }{ the denoised counts of microbiome data}\n#'  \\item{hic}{ the number of the rank selection, chosen by HIC type information criterion}\n\n\n#' @examples\n#' n.n = 60\n#' n.w = 100\n#' n.factors = 2\n#' set.seed(1)\n#' si <- diag(n.factors)\n#' me <- c(0,0)\n#' f <- matrix(0,nrow = n.n, ncol = n.factors)\n#' for(i in 1:n.n){\n#'  f[i,] <- rnorm(n.factors, mean = 0, sd = 1)\n#' }\n#' betaj <- matrix(0,nrow = n.w, ncol = n.factors)\n#' for(j in 1:n.w){\n#'   betaj[j,] <- runif(n.factors,-3,3)\n#' }\n#' alpha <- runif(n.n,-5,5)\n#' beta0 <- rep(0,n.w)\n#' g <- rep(0,n.w*0.5*0.5)\n#' gamma <- c(g,-g,rep(0,(n.w-n.w*0.5)))\n#' X_cov<- c(rep(1,n.n/2),rep(0,n.n/2))\n#' ll <- f %*% t(betaj)  +matrix(alpha,n.n,n.w)+matrix(beta0,n.n,n.w,byrow=TRUE)\n#' exp_mat <- exp(ll)\n#' eta_mat <- matrix(0.25,n.n,n.w,byrow=TRUE)\n#' z <- matrix(0,n.n,n.w,byrow = TRUE)\n#' for(i in 1:n.n){\n#'   z[i,] <- rbinom(n.w, size=1, prob=eta_mat[i,])\n#' }\n#' sum <- rowSums((1-z)*exp_mat)\n#' Qn_z <- (1-z)*exp_mat/sum\n#' sum <- rowSums(exp_mat)\n#' Qn <- exp_mat/sum\n#' X <- matrix(0,n.n,n.w,byrow = TRUE)\n#'  for(i in 1:n.n){\n#'   for(j in 1:n.w){\n#'     X[i,j] <- rnbinom(n=1,size=10,mu=exp_mat[i,j])\n#'  }\n#'  }\n#' X[z==1]=0\n\n#' zerorow <- which(rowSums(X)==0)\n#' if(length(zerorow) >0 ){\n#'    X <- X[-zerorow,];X_cov<-X_cov[-zerorow];f <- f[-zerorow,];\n#'    Qn <- Qn[-zerorow,];Qn_z <- Qn_z[-zerorow,];\n#' }\n#' zerocol <- which(colSums(X)==0)\n#' if(length(zerocol) >0 ){\n#'   X <- X[,-zerocol];betaj <- t(t(betaj)[,-zerocol]);\n#'   Qn <- Qn[,-zerocol];Qn_z <- Qn_z[,-zerocol];\n#' }\n#' re_zinb_cov <- ZIPPCApn(X,X_cov)\n#' re_zinb <- ZIPPCApn(X)\n#'\n#' @export\n\n\nZIPPCApn <- function(X, V=NULL, family = \"negative.binomial\", n.factors=2, rank=FALSE,\n                     trace = FALSE, maxit = 100, parallel=TRUE){\n\n  ZIPNVA <- function(X,V,family = \"negative.binomial\",n.factors,trace,maxit) {\n\n    n.s<-dim(X)[1]; n.f<-dim(X)[2];\n    if(is.null(V)){Y <- 0\n    }else if(is.numeric(V)){Y <- V\n    }else{\n      Y <- as.numeric(as.factor(V))-1}\n\n    out.list <- list()\n\n    ### Initialization\n    X_sc <- scale(log2(1+X),center = T,scale = T)\n    re <- svd(X_sc,n.factors,n.factors)\n    if(n.factors==1){\n      factor_scores <- new.factor_scores <- re$u * (re$d[1])\n    }else{factor_scores <- new.factor_scores <- re$u %*% diag(re$d[1:n.factors])}\n\n    factor_coefs_j <- new.factor_coefs_j <- re$v\n    factor_coefs_0 <-  new.factor_coefs_0 <-  rep(1,n.f)\n    factor_coefs <- cbind(factor_coefs_0,factor_coefs_j)\n    pzero.col <- apply(X, 2, function(x) {sum(x==0)/n.s})\n    z.hat <- pi <- new.pi <- t(ifelse(t(X)==0, pzero.col, 0))\n    tuo_j <- car::logit(colMeans(pi))\n    c_i <- car::logit(rowMeans(pi))\n    #eta <- new.eta <- round(apply(pi, 2, mean), 6)\n    fit <- mvabund::manyglm(X ~ 1, family = family)\n    phi <- fit$phi + 1e-5\n    dispersion <- new.dispersion <- NULL\n    if(any(phi>100))phi[phi>100]=100; if(any(phi<0.10))phi[phi<0.10]=0.10;\n    new.dispersion <- dispersion <- 1/phi\n    sigma <- new.sigma <- matrix(0.01,n.s,n.factors)\n    alpha <- new.alpha <- rep(0,n.s)\n    gamma <-  new.gamma <-  rep(1,n.f)\n\n    ### VA iteration about variational lower bound\n    cur.VLB <- -1e6; iter <- 1; ratio <- 10; diff=1e5;eps = 1e-4;max.iter = 100;\n    m.cur.logfunc <- -1e6; b.cur.logfunc <- -1e6; d.cur.logfunc <- -1e6; s.cur.logfunc <- -1e6;\n    e.cur.logfunc <- -1e6;\n    while((diff> eps*(abs(cur.VLB)+eps)) && iter <= max.iter) {\n      if(trace) cat(\"Iteration:\", iter, \"\\n\")\n      ## VLB\n      VLB <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n        x2 <- x\n        new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n        new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n        new.alpha <- v[1:n.s]\n        new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n        new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n        new.gamma <- x2[1:n.f]\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- pi\n        new.dispersion <- d\n        new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n        new.ci <- eta[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n        dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y +matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n        if(family == \"negative.binomial\"){\n          e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          a <- (1-new.pi)*(lgamma(X+dispersion.mat)-lfactorial(X)-lgamma(dispersion.mat)-(X+dispersion.mat)*log(1+dispersion.mat/exp(e.mat))+dispersion.mat*log(dispersion.mat)-dispersion.mat*ll)\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          b <- -(1-new.pi)*dispersion.mat*log(1+exp(e.mat)/dispersion.mat)\n        }\n        if(family == \"poisson\"){\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          a <- (1-new.pi)*(X * ll - lfactorial(X) - exp(e.mat))\n          b <- (1-new.pi)*(- exp(e.mat))\n        }\n        y1 <- ifelse(X>0,a,b)\n        fun2 <- function(i) { 0.5 * (sum(log(t(new.sigma)[,i])) - sum(t(new.sigma)[,i]) - sum(new.factor_scores[i,]^2)) }\n        y3 <- new.pi*new.eta-log(1+exp(new.eta))-(1-new.pi)*log(1-new.pi)-I(X==0)*new.pi*log(new.pi)\n        y <- sum(y1)+ sum(sapply(1:n.s,fun2))+sum(y3,na.rm=T)\n        return(y)\n      }\n\n      log_base <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n        x2 <- x\n        new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n        new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n        new.alpha <- v[1:n.s]\n        new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n        new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n        new.gamma <- x2[1:n.f]\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- pi\n        new.dispersion <- d\n        new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n        new.ci <- eta[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n        dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y +matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n        if(family == \"negative.binomial\"){\n          c <- (1-new.pi)*(lgamma(X+dispersion.mat)-lfactorial(X)-lgamma(dispersion.mat)+X*log(exp(ll)/(dispersion.mat+exp(ll)))+dispersion.mat*log(dispersion.mat/(dispersion.mat+exp(ll))))\n\n        }\n        if(family == \"poisson\"){\n          c <- (1-new.pi)*(X * ll - lfactorial(X) - exp(ll))\n        }\n\n        y <- sum(c)\n        return(y)\n      }\n\n      ## update tuo,ci\n      eta_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n        x2 <- x\n        new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n        new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n        new.alpha <- v[1:n.s]\n        new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n        new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n        new.gamma <- x2[1:n.f]\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- pi\n        new.dispersion <- d\n        new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n        new.ci <- eta[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n        y1 <- new.pi*new.eta-log(1+exp(new.eta))\n        y <- sum(y1)\n        return(y)\n      }\n      eta_grad_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n        x2 <- x\n        new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n        new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n        new.alpha <- v[1:n.s]\n        new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n        new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n        new.gamma <- x2[1:n.f]\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- pi\n        new.dispersion <- d\n        new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n        new.ci <- eta[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n        grad <- new.pi-exp(new.eta)/(1+exp(new.eta))\n\n        return(c(colSums(grad), rowSums(grad)))\n      }\n      q <- try(optim(c(tuo_j,c_i),x=c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma), pi = new.pi,d=new.dispersion, method = \"BFGS\", fn = eta_f, gr = eta_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.tuo <- tuo_j; new.ci <- c_i;\n      }else{\n        if(iter > 1 && e.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of eta did not improve on iteration step \",iter,\"\\n\");\n          new.tuo <- tuo_j; new.ci <- c_i;\n        }else{\n          if(trace) cat(\"Model parameters eta updated\",\"\\n\")\n          new.tuo <- q$par[1:n.f]; x2 <- q$par[-(1:n.f)];\n          new.ci <- x2[1:n.s]\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of eta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ## update beta,beta0,gamma\n      beta_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n        x2 <- x\n        new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n        new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n        new.alpha <- v[1:n.s]\n        new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n        new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n        new.gamma <- x2[1:n.f]\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- pi\n        new.dispersion <- d\n        new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n        new.ci <- eta[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n        dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n        bl<- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE) +matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + new.factor_scores %*% t(new.factor_coefs_j)\n        if(family==\"negative.binomial\"){\n          e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          a <- (1-new.pi)*(-(X+dispersion.mat)*log(1+dispersion.mat/exp(e.mat))-dispersion.mat*bl)\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          b <- -(1-new.pi)*dispersion.mat*log(1+exp(e.mat)/dispersion.mat)\n        }\n        if(family==\"poisson\"){\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          a <- (1-new.pi)*(X*bl-exp(e.mat))\n          b <- (1-new.pi)*(-exp(e.mat))\n        }\n        y1 <- ifelse(X>0,a,b)\n        y <- sum(y1)\n        return(y)\n      }\n      beta_grad_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n        x2 <- x\n        new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n        new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n        new.alpha <- v[1:n.s]\n        new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n        new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n        new.gamma <- x2[1:n.f]\n        new.sigma <- matrix(s,n.s,n.factors)\n        new.pi <- pi\n        new.dispersion <- d\n        new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n        new.ci <- eta[1:n.s]\n\n        new.pi[X==0] <- new.pi[X==0]-1e-8\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n        b3 <- b2 <-  b30 <- b20 <- beta_grad <- beta0_grad <- ga <- ga0 <- gamma_grad <- NULL\n        dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y +matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n        if(family==\"negative.binomial\"){\n          e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          e.mat2 <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          for(w in 1:n.factors){\n            b3 <- c(b3,(1-new.pi)*(sweep(-dispersion.mat,1,new.factor_scores[,w],\"*\") + sweep((new.sigma[,w]%*%t(new.factor_coefs_j[,w])),1,-new.factor_scores[,w],\"+\") * (-(X + dispersion.mat) * (dispersion.mat / (exp(e.mat) + dispersion.mat)))))\n            b30 <- c(b30,-(1-new.pi)*(sweep((new.sigma[,w]%*%t(new.factor_coefs_j[,w])),1,new.factor_scores[,w],\"+\") * (exp(e.mat2)/(1+exp(e.mat2)/dispersion.mat))))\n          }\n          b2 <- (1-new.pi)*((X+dispersion.mat)*(dispersion.mat/(exp(e.mat)+dispersion.mat))-dispersion.mat)\n          b20 <- -(1-new.pi)*(exp(e.mat2)/(1+exp(e.mat2)/dispersion.mat))\n          ga <- (1-new.pi)*((X+dispersion.mat)*(dispersion.mat/(exp(e.mat)+dispersion.mat))-dispersion.mat)*Y\n          ga0 <- -(1-new.pi)*(exp(e.mat2)/(1+exp(e.mat2)/dispersion.mat))*Y\n        }\n        if(family==\"poisson\"){\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          for(w in 1:n.factors){\n            b3 <- c(b3,(1-new.pi)*(sweep(X,1,new.factor_scores[,w],\"*\") - sweep((new.sigma[,w]%*%t(new.factor_coefs_j[,w])),1,new.factor_scores[,w],\"+\") * exp(e.mat)))\n            b30 <- c(b30,(1-new.pi)*(- sweep((new.sigma[,w]%*%t(new.factor_coefs_j[,w])),1,new.factor_scores[,w],\"+\") * exp(e.mat)))\n          }\n          b2 <- (1-new.pi)*(X-exp(e.mat))\n          b20 <- (1-new.pi)*(-exp(e.mat))\n          ga <- (1-new.pi)*(X-exp(e.mat))*Y\n          ga0 <- (1-new.pi)*(-exp(e.mat))*Y\n        }\n        X2 <- matrix(X,n.s,n.f*n.factors)\n        b3 <- matrix(b3,n.s,n.f*n.factors)\n        b30 <- matrix(b30,n.s,n.f*n.factors)\n        beta_grad <- ifelse(X2>0,b3,b30)\n        beta0_grad <- ifelse(X>0,b2,b20)\n        gamma_grad <- ifelse(X>0,ga,ga0)\n        return(c(colSums(beta_grad), colSums(beta0_grad), colSums(gamma_grad)))\n      }\n      q <- try(optim(c(factor_coefs_j,factor_coefs_0,gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma), pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion, method = \"BFGS\", fn = beta_f, gr = beta_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n      if(\"try-error\" %in% class(q)){ new.factor_coefs_j <- factor_coefs_j; new.factor_coefs_0 <- factor_coefs_0;new.gamma <- gamma\n      }else{\n        if(iter > 1 && b.cur.logfunc > q$value){if(trace)\n          cat(\"Optimization of beta did not improve on iteration step \",iter,\"\\n\");\n          new.factor_coefs_j <- factor_coefs_j; new.factor_coefs_0 <- factor_coefs_0;new.gamma <- gamma\n        }else{\n          if(trace) cat(\"Model parameters beta updated\",\"\\n\")\n          new.factor_coefs_j <- matrix(q$par[1:(n.f * n.factors)],n.f,n.factors); x2 <- q$par[-(1:(n.f * n.factors))];\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)];\n          new.gamma <- x2[1:n.f]\n          if(q$convergence != 0) { if(trace) cat(\"Optimization of beta did not converge on iteration step \", iter,\"\\n\") }\n        }\n      }\n\n      ## update dispersion\n      if(family==\"negative.binomial\") {\n        dispersion_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n          x2 <- x\n          new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n          new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n          new.alpha <- v[1:n.s]\n          new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n          new.gamma <- x2[1:n.f]\n          new.sigma <- matrix(s,n.s,n.factors)\n          new.pi <- pi\n          new.dispersion <- d\n          new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n          new.ci <- eta[1:n.s]\n\n          new.pi[X==0] <- new.pi[X==0]-1e-8\n          new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n          e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          a <- (1-new.pi)*(lgamma(X+dispersion.mat)-lgamma(dispersion.mat)-(X+dispersion.mat)*log(1+dispersion.mat/exp(e.mat))+dispersion.mat*log(dispersion.mat)-dispersion.mat*ll)\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          b <- -(1-new.pi)*dispersion.mat*log(1+exp(e.mat)/dispersion.mat)\n          y1 <- ifelse(X>0,a,b)\n          y <- sum(y1)\n          return(y)\n        }\n\n        dispersion_grad_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n          x2 <- x\n          new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n          new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n          new.alpha <- v[1:n.s]\n          new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n          new.gamma <- x2[1:n.f]\n          new.sigma <- matrix(s,n.s,n.factors)\n          new.pi <- pi\n          new.dispersion <- d\n          new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n          new.ci <- eta[1:n.s]\n\n          new.pi[X==0] <- new.pi[X==0]-1e-8\n          new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n          grad.dispersion <-grad.d <- grad.d0 <- NULL\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n          e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          grad.d <- (1-new.pi)*(digamma(X+dispersion.mat)-digamma(dispersion.mat)-log(1+dispersion.mat/exp(e.mat))-(X+dispersion.mat)/\n                                  (exp(e.mat)+dispersion.mat)+log(dispersion.mat)+1-ll)\n          e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n          grad.d0 <- -(1-new.pi)*(log(1+exp(e.mat)/dispersion.mat)-exp(e.mat)/(1+exp(e.mat)/dispersion.mat)/dispersion.mat)\n          grad.dispersion <- ifelse(X>0,grad.d,grad.d0)\n          return(colSums(grad.dispersion))\n        }\n        q <- try(optim(c(dispersion),x=c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma), pi = new.pi,eta = c(new.tuo,new.ci), method = \"BFGS\", fn = dispersion_f, gr = dispersion_grad_f, control = list(trace = 0, fnscale = -1, maxit = maxit)), silent = TRUE)\n        if(\"try-error\" %in% class(q)){ new.dispersion <- dispersion\n        }else{\n          if(iter > 1 && d.cur.logfunc > q$value){if(trace)\n            cat(\"Optimization of dispersion did not improve on iteration step \",iter,\"\\n\");\n            new.dispersion <- dispersion;\n          }else{\n            if(trace) cat(\"Model parameters dispersion updated\",\"\\n\")\n            new.dispersion <- q$par[1:n.f];\n            if(q$convergence != 0) { if(trace) cat(\"Optimization of dispersion did not converge on iteration step \", iter,\"\\n\") }\n          }\n        }\n      }\n\n      delta.pi.required <- 1e-3; p.iter <- 1; p.max.iter <- 10; delta.pi <- abs(pi);\n      while(!all(delta.pi < delta.pi.required) & (p.iter < p.max.iter)){\n        ## update pi\n        new.pi <- matrix(0,n.s,n.f,byrow = TRUE)\n        ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n        e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n        new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n\n        if(family==\"negative.binomial\"){\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          sum1 <- exp(-dispersion.mat*log(1+exp(e.mat)/dispersion.mat))\n        }\n        if(family==\"poisson\"){\n          sum1 <- exp( - exp(e.mat))\n        }\n        new.pi <- 1/(1+exp(-new.eta)*sum1)\n        new.pi[X!=0]=0\n\n        ## update sigma\n        s_f <-function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL){\n          x2 <- x\n          new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n          new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n          new.alpha <- v[1:n.s]\n          new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n          new.gamma <- x2[1:n.f]\n          new.sigma <- matrix(s,n.s,n.factors)\n          new.pi <- pi\n          new.dispersion <- d\n          new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n          new.ci <- eta[1:n.s]\n\n          new.pi[X==0] <- new.pi[X==0]-1e-8\n          new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n          y1 <- rep(0,n.s)\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n\n          for(i in 1:n.s){\n            if(n.factors==1){\n              y1[i] <- -1/2*((new.sigma[i])-log(new.sigma[i]))\n            }else{\n              y1[i] <- -1/2*(sum(new.sigma[i,])-log(det(diag(new.sigma[i,]))))\n            }}\n\n          if(family==\"negative.binomial\"){\n            e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            a <- (1-new.pi)*(-(X+dispersion.mat)*log(1+dispersion.mat/exp(e.mat)))\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            b <- -(1-new.pi)*dispersion.mat*log(1+exp(e.mat)/dispersion.mat)\n            y2 <- ifelse(X>0,a,b)\n          }\n          if(family==\"poisson\"){\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            y2 <- -(1-new.pi)*exp(e.mat)\n          }\n          y <- sum(y1)+sum(y2)\n          return(y)\n        }\n        s_grad_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL){\n          x2 <- x\n          new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n          new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n          new.alpha <- v[1:n.s]\n          new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n          new.gamma <- x2[1:n.f]\n          new.sigma <- matrix(s,n.s,n.factors)\n          new.pi <- pi\n          new.dispersion <- d\n          new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n          new.ci <- eta[1:n.s]\n\n          new.pi[X==0] <- new.pi[X==0]-1e-8\n          new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n          grad.sigma <- matrix(0,n.s,n.factors,byrow = TRUE)\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y +matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n          if(family==\"negative.binomial\"){\n            e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            mu <- -0.5*(1-new.pi)*((X+dispersion.mat)*(dispersion.mat/(exp(e.mat)+dispersion.mat)))\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            mu2 <- -0.5*(1-new.pi)*(exp(e.mat)/(1+exp(e.mat)/dispersion.mat))\n            mu.mat <- ifelse(X>0,mu,mu2)\n          }\n          if(family==\"poisson\"){\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            mu.mat <- -0.5*(1-new.pi)*exp(e.mat)\n          }\n          beta2 <- new.factor_coefs_j^2\n\n          for(i in 1:n.s){\n            if(n.factors==1){\n              grad.sigma[i] <- diag(-0.5*(diag(rep(1,n.factors))-(new.sigma[i])^-1) + sum(mu.mat[i,]*beta2))\n            }else{\n              grad.sigma[i,] <- diag(-0.5*(diag(rep(1,n.factors))-(diag(new.sigma[i,]))^-1) + diag(apply(mu.mat[i,]*beta2,2,sum)))\n            }}\n\n          return(c(grad.sigma))\n        }\n        q <- try(constrOptim(c(sigma), method = \"BFGS\", f = s_f, grad = s_grad_f, x = c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion,ui=diag(1,n.s*n.factors,n.s*n.factors),ci=rep(1e-8,n.s*n.factors),control = list(trace = 0, fnscale = -1, maxit = maxit,reltol=1e-6)), silent = TRUE)\n        if(\"try-error\" %in% class(q)){ new.sigma <- sigma\n        }else{\n          if(iter > 1 && s.cur.logfunc > q$value){if(trace)\n            cat(\"Optimization of sigma did not improve on iteration step \",iter,\"\\n\");\n            new.sigma <- sigma;\n          }else{\n            if(trace) cat(\"Variational parameters sigma updated\",\"\\n\")\n            new.sigma <- q$par[1:(n.factors*n.s)]; new.sigma <- matrix(new.sigma,n.s,n.factors);\n            if(q$convergence != 0) { if(trace) cat(\"Optimization of sigma did not converge on iteration step \", iter,\"\\n\") }\n          }\n        }\n\n        ## update factor_scores and alpha\n        m_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL){\n          x2 <- x\n          new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n          new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n          new.alpha <- v[1:n.s]\n          new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n          new.gamma <- x2[1:n.f]\n          new.sigma <- matrix(s,n.s,n.factors)\n          new.pi <- pi\n          new.dispersion <- d\n          new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n          new.ci <- eta[1:n.s]\n\n          new.pi[X==0] <- new.pi[X==0]-1e-8\n          new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          bl<- new.factor_scores %*% t(new.factor_coefs_j)+ matrix(new.alpha,n.s,n.f)\n          ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n          if(family==\"negative.binomial\"){\n            e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            a <- (1-new.pi)*(-(X+dispersion.mat)*log(1+dispersion.mat/exp(e.mat))-dispersion.mat*bl)\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            b <- -(1-new.pi)*dispersion.mat*log(1+exp(e.mat)/dispersion.mat)\n          }\n          if(family==\"poisson\"){\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            a <- (1-new.pi)*(X * bl - exp(e.mat))\n            b <- (1-new.pi)*(- exp(e.mat))\n          }\n          y3 <- ifelse(X>0,a,b)\n          foo2 <- function(i) { -0.5 *  sum(factor_scores[i,]^2) }\n          y <- sum(y3) + sum(sapply(1:n.s,foo2))\n          return(y)\n        }\n        m_grad_f <- function(x,v=NULL,s=NULL,pi=NULL,eta=NULL,d=NULL) {\n          x2 <- x\n          new.factor_scores <- new.factor_coefs_j <- new.factor_coefs_0 <- new.alpha <- new.sigma <- NULL\n          new.factor_scores <- matrix(c(v[1:(n.s*n.factors)]),n.s,n.factors); v <- v[-(1:(n.s*n.factors))]\n          new.alpha <- v[1:n.s]\n          new.factor_coefs_j <- matrix(c(x2[1:(n.f * n.factors)]),n.f,n.factors); x2 <- x2[-(1:(n.f * n.factors))]\n          new.factor_coefs_0 <- x2[1:n.f]; x2 <- x2[-(1:n.f)]\n          new.gamma <- x2[1:n.f]\n          new.sigma <- matrix(s,n.s,n.factors)\n          new.pi <- pi\n          new.dispersion <- d\n          new.tuo <- eta[1:n.f]; eta <- eta[-(1:n.f)]\n          new.ci <- eta[1:n.s]\n\n          new.pi[X==0] <- new.pi[X==0]-1e-8\n          new.eta <- matrix(new.tuo,n.s, n.f,byrow = T)+ matrix(new.ci,n.s, n.f)\n          grad.m <- grad.alpha <- NULL\n          dispersion.mat <- matrix(new.dispersion,n.s,n.f,byrow=TRUE)\n          ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y +matrix(new.alpha,n.s,n.f) + new.factor_scores %*% t(new.factor_coefs_j)\n          if(family==\"negative.binomial\"){\n            e.mat <- ll - 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            sum1 <- (1-new.pi)*((X+dispersion.mat)*(dispersion.mat/(exp(e.mat)+dispersion.mat))-dispersion.mat)\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            sum2 <- -(1-new.pi)*(exp(e.mat)/(1+exp(e.mat)/dispersion.mat))\n          }\n          if(family==\"poisson\"){\n            e.mat <- ll + 0.5 * (new.sigma) %*% t(new.factor_coefs_j^2)\n            sum1 <- (1-new.pi)*(X-exp(e.mat))\n            sum2 <- (1-new.pi)*(-exp(e.mat))\n          }\n          sum <- ifelse(X>0,sum1,sum2)\n          for(l in 1:n.factors) {\n            grad.m <- c(grad.m,rowSums(sweep(sum,2,new.factor_coefs_j[,l],\"*\"))-new.factor_scores[,l])\n          }\n          grad.alpha <-rowSums(sum)\n\n          return(c(grad.m,grad.alpha))\n        }\n        q <- try(optim(c(factor_scores,alpha), method = \"BFGS\", fn = m_f, gr = m_grad_f, x = c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), s = c(new.sigma), pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion,control = list(trace = 0, fnscale = -1, maxit = maxit,reltol=1e-6)), silent = TRUE)\n        if(\"try-error\" %in% class(q)){ new.factor_scores <- factor_scores; new.alpha <- alpha\n        }else{\n          if(iter > 1 && m.cur.logfunc > q$value){if(trace)\n            cat(\"Optimization of m and alpha did not improve on iteration step\",iter,\"\\n\");\n            new.factor_scores <- factor_scores; new.alpha <- alpha;\n          }else{\n            if(trace) cat(\"Variational parameters m and alpha updated\",\"\\n\")\n            new.factor_scores <- matrix(q$par[1:(n.factors*n.s)],n.s,n.factors); x2 <- q$par[-(1:(n.s * n.factors))];\n            new.alpha <- x2[1:n.s]; x2 <- x2[-(1:n.s)];\n            if(q$convergence != 0) { if(trace) cat(\"Optimization of m and alpha did not converge on iteration step\", iter,\"\\n\") }\n          }\n        }\n\n        q_m <- list(value = m_f(c(new.factor_scores,new.alpha), x = c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), s = c(new.sigma), pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion))\n        m.new.logfunc <- q_m$value\n        m.cur.logfunc <- m.new.logfunc\n\n        q_s <- list(value = s_f(c(new.sigma), x = c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion))\n        s.new.logfunc <- q_s$value\n        s.cur.logfunc <- s.new.logfunc\n\n        delta.pi <- abs(new.pi-pi)\n        sigma <- new.sigma\n        factor_scores <- new.factor_scores\n        alpha <- new.alpha\n        pi <- new.pi\n        p.iter <- p.iter+1\n      }\n\n      q_b <- list(value = beta_f(c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma), pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion))\n      b.new.logfunc <- q_b$value\n      b.cur.logfunc <- b.new.logfunc\n\n      q_e <- list(value = eta_f(c(new.tuo,new.ci),x=c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma), pi = new.pi,d=new.dispersion))\n      e.new.logfunc <- q_e$value\n      e.cur.logfunc <- e.new.logfunc\n\n      if(family==\"negative.binomial\"){\n        q_d <- list(value = dispersion_f(c(new.dispersion), x=c(new.factor_coefs_j,new.factor_coefs_0,new.gamma),v = c(new.factor_scores,new.alpha), s = c(new.sigma), pi = new.pi,eta = c(new.tuo,new.ci)))\n        d.new.logfunc <- q_d$value\n        d.cur.logfunc <- d.new.logfunc\n      }\n\n      ## Take values of VLB to define stopping rule\n      q <- list(value = VLB(c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma),pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion))\n      new.VLB <- q$value\n      diff=abs(new.VLB-cur.VLB)\n      ratio <- abs(new.VLB/cur.VLB);\n      if(trace) cat(\"New VLB:\", new.VLB,\"cur VLB:\", cur.VLB, \"Ratio of VLB\", ratio, \". Difference in VLB:\",diff,\"\\n\")\n      cur.VLB <- new.VLB\n\n      q <- list(value = log_base(c(new.factor_coefs_j,new.factor_coefs_0,new.gamma), v = c(new.factor_scores,new.alpha), s = c(new.sigma),pi = new.pi,eta = c(new.tuo,new.ci),d=new.dispersion))\n      cur.log<- q$value\n\n      tuo_j <- new.tuo;\n      c_i <- new.ci;\n      alpha <- new.alpha;\n      factor_coefs_0 <-new.factor_coefs_0;\n      factor_coefs_j <- new.factor_coefs_j;\n      gamma <- new.gamma\n      factor_scores <- new.factor_scores;\n      sigma <- new.sigma;\n      pi <- new.pi;\n      if(family==\"negative.binomial\"){dispersion <- new.dispersion}\n\n      iter <- iter + 1\n    }\n\n    if(iter > 99){\n      print(paste(family,\"ZIPPCA Not converging!\"))\n    }\n\n    if(family==\"negative.binomial\"){\n      ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(alpha,n.s,n.f) + factor_scores %*% t(factor_coefs_j)\n      dispersion.mat <- matrix(dispersion,n.s,n.f,byrow=TRUE)\n      e.mat <- ll + 0.5 * (sigma) %*% t(factor_coefs_j^2)\n      e.mat2 <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y  + matrix(alpha,n.s,n.f)+ factor_scores %*% t(factor_coefs_j) - 0.5 * (sigma) %*% t(factor_coefs_j^2)\n      e.mat3 <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y  + factor_scores %*% t(factor_coefs_j) + 0.5 * (sigma) %*% t(factor_coefs_j^2)\n\n      mu_p <- (exp(e.mat)+dispersion.mat)/(1+dispersion.mat/exp(e.mat2))\n      Q_nb <- mu_p/rowSums(mu_p)\n      Q_nb_z <- (1-new.pi)*mu_p/(rowSums((1-new.pi)*mu_p))\n      mu_z <- (1-new.pi)*exp(e.mat3)\n    }\n    if(family==\"poisson\"){\n      ll <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y + matrix(alpha,n.s,n.f) + factor_scores %*% t(factor_coefs_j)\n      e.mat <- ll + 0.5 * (sigma) %*% t(factor_coefs_j^2)\n      Q_poi <- exp(e.mat)/rowSums(exp(e.mat))\n      Q_poi_z <- (1-new.pi)*exp(e.mat)/(rowSums((1-new.pi)*exp(e.mat)))\n      e.mat2 <- matrix(new.factor_coefs_0,n.s,n.f,byrow=TRUE)+matrix(new.gamma,n.s,n.f,byrow=TRUE)*Y  + factor_scores %*% t(factor_coefs_j) + 0.5 * (sigma) %*% t(factor_coefs_j^2)\n      mu_z <- (1-new.pi)*exp(e.mat2)\n\n    }\n\n    ## print the output\n    out.list$VLB <- cur.VLB\n    out.list$CLL <- cur.log\n    out.list$iter=iter-1\n    out.list$lvs$pi <- pi\n    out.list$lvs$factor_scores <- factor_scores\n    out.list$lvs$sigma <- sigma\n    out.list$params$factor_coefs_j <- factor_coefs_j\n    out.list$params$factor_coefs_0 <- factor_coefs_0\n    out.list$params$gamma <- gamma\n    out.list$params$alpha <- alpha\n    out.list$params$tuo <- tuo_j\n    out.list$params$c <- c_i\n    if(family==\"negative.binomial\"){\n      out.list$params$dispersion <- dispersion\n      out.list$mu <- exp(e.mat3)\n      out.list$Q <- Q_nb\n      out.list$muz <- mu_z\n      out.list$Qz <- Q_nb_z\n    }\n    if(family==\"poisson\"){\n      out.list$Q <- Q_poi\n      out.list$mu <- exp(e.mat2)\n      out.list$muz <- mu_z\n      out.list$Qz <- Q_poi_z\n    }\n\n    return(out.list)\n  }\n\n  if(rank==FALSE & family == \"negative.binomial\"){\n    re <- tryCatch({ZIPNVA(X,V,family = \"negative.binomial\",n.factors,trace,maxit)},error=function(e){NaN})\n  }else if(rank==FALSE & family == \"poisson\"){\n    re <- tryCatch({ZIPNVA(X,V,family = \"poisson\",n.factors,trace,maxit)},error=function(e){NaN})\n  }else if(rank==TRUE){\n    if (parallel){\n      #cl <- parallel::makeCluster(detectCores(logical = FALSE))\n      cl <- parallel::makeCluster(getOption(\"cl.cores\", 4))\n      doParallel::registerDoParallel(cl)\n    }\n    out.list <- list()\n    p <- ncol(X)\n    n <- nrow(X)\n    r <- 5\n    fold <- 5\n    beta <- list()\n    beta0 <- list()\n    f <- list()\n    Q <- list()\n    pi <- list()\n    mu <- list()\n    gamma <- list()\n    alpha <- list()\n    sigma <- list()\n    Qz <- list()\n    muz <- list()\n    tuo <- list()\n    c <- list()\n    lob <- rep(NaN,r)\n    iter <- rep(NaN,r)\n    L <- rep(NaN,r)\n    hic <- rep(NaN,r)\n    if(family == \"negative.binomial\"){dispersion <- list()}\n\n    if (parallel){\n      Mres <- foreach::foreach(w=1:r) %dopar% {\n        if(family == \"negative.binomial\"){\n          re <- tryCatch({ZIPNVA(X,V,family = \"negative.binomial\",n.factors=w,trace,maxit)},error=function(e){NaN})\n        }else if(family == \"poisson\"){\n          re <- tryCatch({ZIPNVA(X,V,family = \"poisson\",n.factors=w,trace,maxit)},error=function(e){NaN})\n        }\n        re\n      }\n      for(w in 1:r){\n        if(!is.na(Mres[[w]]$VLB)){\n          L[w] <- Mres[[w]]$VLB\n          lob[w] <-  Mres[[w]]$CLL\n          iter[w] <- Mres[[w]]$iter\n          beta[[w]] <- Mres[[w]]$params$factor_coefs_j\n          beta0[[w]] <- Mres[[w]]$params$factor_coefs_0\n          gamma[[w]] <- Mres[[w]]$params$gamma\n          alpha[[w]] <- Mres[[w]]$params$alpha\n          f[[w]] <- Mres[[w]]$lvs$factor_scores\n          sigma[[w]] <- Mres[[w]]$lvs$sigma\n          pi[[w]] <- Mres[[w]]$lvs$pi\n          mu[[w]] <- Mres[[w]]$mu\n          Qz[[w]] <- Mres[[w]]$Qz\n          Q[[w]] <- Mres[[w]]$Q\n          muz[[w]] <- Mres[[w]]$muz\n          tuo[[w]] <- Mres[[w]]$params$tuo\n          c[[w]] <- Mres[[w]]$params$c\n          hic[w] <- -2*lob[w]+log(n)*(w*p-w^2)+2*w*n\n          if(family == \"negative.binomial\"){dispersion[[w]] <- Mres[[w]]$params$dispersion}\n        }else{\n          L[w] <- NaN\n          lob[w] <- NaN\n          iter[w] <- NaN\n          beta[[w]] <- NaN\n          beta0[[w]] <- NaN\n          tuo[[w]] <- NaN\n          c[[w]] <- NaN\n          alpha[[w]] <- NaN\n          gamma[[w]] <- NaN\n          sigma[[w]] <- NaN\n          f[[w]] <- NaN\n          Q[[w]] <- NaN\n          Qz[[w]] <- NaN\n          pi[[w]] <- NaN\n          hic[w] <- NaN\n          mu[[w]] <- NaN\n          muz[[w]] <- NaN\n          if(family == \"negative.binomial\"){dispersion[[w]] <- NaN}\n        }\n      }\n    }else{\n      for(w in 1:r){\n        if(family == \"negative.binomial\"){\n          re <- tryCatch({ZIPNVA(X,V,family = \"negative.binomial\",n.factors=w,trace,maxit)},error=function(e){NaN})\n        }else if(family == \"poisson\"){\n          re <- tryCatch({ZIPNVA(X,V,family = \"poisson\",n.factors=w,trace,maxit)},error=function(e){NaN})\n        }\n        if(!is.na(re$VLB)){\n          L[w] <- re$VLB\n          lob[w] <- re$CLL\n          iter[w] <- re$iter\n          beta[[w]] <- re$params$factor_coefs_j\n          beta0[[w]] <- re$params$factor_coefs_0\n          gamma[[w]] <- re$params$gamma\n          alpha[[w]] <- re$params$alpha\n          sigma[[w]] <- re$lvs$sigma\n          f[[w]] <- re$lvs$factor_scores\n          Q[[w]] <- re$Q\n          mu[[w]] <- re$mu\n          Qz[[w]] <- re$Qz\n          muz[[w]] <- re$muz\n          tuo[[w]] <- re$params$tuo\n          c[[w]] <- re$params$c\n          pi[[w]] <- re$lvs$pi\n          hic[w] <- -2*lob[w]+log(n)*(w*p-w^2)+2*w*n\n          if(family == \"negative.binomial\"){dispersion[[w]] <-  re$params$dispersion}\n        }else{\n          L[w] <- NaN\n          lob[w] <- NaN\n          iter[w] <- NaN\n          beta[[w]] <- NaN\n          beta0[[w]] <- NaN\n          tuo[[w]] <- NaN\n          c[[w]] <- NaN\n          alpha[[w]] <- NaN\n          gamma[[w]] <- NaN\n          sigma[[w]] <- NaN\n          f[[w]] <- NaN\n          Q[[w]] <- NaN\n          Qz[[w]] <- NaN\n          pi[[w]] <- NaN\n          hic[w] <- NaN\n          mu[[w]] <- NaN\n          muz[[w]] <- NaN\n          if(family == \"negative.binomial\"){dispersion[[w]] <- NaN}\n        }\n      }\n    }\n\n    out.list$hic <- which.min(hic)\n    out.list$VLB <- L[[which.min(hic)]]\n    out.list$CLL <- lob[[which.min(hic)]]\n    out.list$iter <- iter[[which.min(hic)]]\n    out.list$lvs$pi <- pi[[which.min(hic)]]\n    out.list$lvs$factor_scores <- f[[which.min(hic)]]\n    out.list$lvs$factor_scores2 <- f[[2]]\n    out.list$lvs$sigma <- sigma[[which.min(hic)]]\n    out.list$params$factor_coefs_j <- beta[[which.min(hic)]]\n    out.list$params$factor_coefs_0 <- beta0[[which.min(hic)]]\n    out.list$params$alpha <- alpha[[which.min(hic)]]\n    out.list$params$gamma <- gamma[[which.min(hic)]]\n    out.list$params$tuo <- tuo[[which.min(hic)]]\n    out.list$params$c <- c[[which.min(hic)]]\n    out.list$Q <- Q[[which.min(hic)]]\n    out.list$mu <- mu[[which.min(hic)]]\n    out.list$Qz <- Qz[[which.min(hic)]]\n    out.list$muz <- muz[[which.min(hic)]]\n\n    if(family==\"negative.binomial\"){\n      out.list$params$dispersion <- dispersion[[which.min(hic)]]\n    }\n\n    if (parallel){\n      parallel::stopCluster(cl = cl)\n    }\n    return(out.list)\n\n  }\n}\n\n",
    "created" : 1624784552065.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3367777536",
    "id" : "4B249C84",
    "lastKnownWriteTime" : 1624806455,
    "last_content_update" : 1624806455333,
    "path" : "~/云盘/mbDenoise/R/ZIPPCApn.R",
    "project_path" : "R/ZIPPCApn.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}